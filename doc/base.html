<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.base</title>
        </head><body>
        <h1>quantities.base</h1>
        <!-- Generated by Ddoc from source/quantities/base.d -->
This module defines the <u>base</u> types for unit and quantity handling.
<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="Quantity"></a>struct <u>Quantity</u>(N, Dim...);
</big></dt>
<dd>A quantity which holds a value and some dimensions.
<br><br>
The value is stored internally as a field of type N.
A dimensionless quantity can be cast to a builtin numeric type.
<br><br>

Arithmetic operators (+ - * /), as well as assignment and comparison operators,
are defined when the operations are dimensionally correct, otherwise an error
occurs at compile-time.<br><br>

<dl><dt><big><a name="valueType"></a>alias <u>valueType</u> = N;
</big></dt>
<dd>The type of the underlying numeric value.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(meter.<u>valueType</u> == <font color=blue>real</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="dimensions"></a>alias <u>dimensions</u> = Dim;
</big></dt>
<dd>The dimension tuple of the quantity.<br><br>

</dd>
<dt><big><a name="baseUnit"></a>Quantity <u>baseUnit</u>();
</big></dt>
<dd>Gets the base unit of this quantity.<br><br>

</dd>
<dt><big><a name="value"></a>const N <u>value</u>(Q)(Q <i>target</i>) if (isQuantity!Q);
<br><a name="value"></a>const N <u>value</u>(string target)();
</big></dt>
<dd>Gets the scalar value of this quantity expressed in the given target unit.<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> time = 120 * minute;
<font color=blue>assert</font>(time.<u>value</u>(hour) == 2);
<font color=blue>assert</font>(time.<u>value</u>(minute) == 120);
<font color=blue>assert</font>(time.<u>value</u>(second) == 7200);
<font color=blue>assert</font>(time.<u>value</u>!<font color=red>"h"</font> == 2);
</pre>
<br><br></dd>
<dt><big><a name="isConsistentWith"></a>const bool <u>isConsistentWith</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br><a name="isConsistentWith"></a>const bool <u>isConsistentWith</u>(string other)();
</big></dt>
<dd>Tests wheter this quantity has the same dimensions as another one.<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> nm = (1.4 * newton) * (0.5 * centi(meter));
<font color=blue>auto</font> kWh = (4000 * kilo(watt)) * (1200 * hour);
<font color=blue>assert</font>(nm.<u>isConsistentWith</u>(kWh)); <font color=green>// Energy in both cases
</font><font color=blue>assert</font>(!nm.<u>isConsistentWith</u>(second));
<font color=blue>assert</font>(nm.<u>isConsistentWith</u>!<font color=red>"kW h"</font>);
</pre>
<br><br></dd>
<dt><big><a name="store"></a>const auto <u>store</u>(T)() if (isNumeric!T);
</big></dt>
<dd>Returns a new quantity where the value is stored in a field of type T.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> size = meter.<u>store</u>!<font color=blue>float</font>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(size.valueType == <font color=blue>float</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="opCast"></a>const Q <u>opCast</u>(Q)() if (isQuantity!Q);
</big></dt>
<dd>Cast a quantity to another quantity type with the same dimensions<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Length = QuantityType!(meter, <font color=blue>float</font>);
<font color=blue>auto</font> m = <font color=blue>cast</font>(Length) meter;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(meter.valueType == <font color=blue>real</font>));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(m.valueType == <font color=blue>float</font>));

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <font color=blue>cast</font>(Time) meter));
</pre>
<br><br>
</dd>
<dt><big><a name="opCast"></a>const T <u>opCast</u>(T)() if (isNumeric!T);
</big></dt>
<dd>Cast a dimensionless quantity to a scalar numeric type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> proportion = 12 * gram / (4.5 * kilogram);
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(QuantityType!proportion == Dimensionless));
<font color=blue>auto</font> prop = <font color=blue>cast</font>(<font color=blue>real</font>) proportion;

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <font color=blue>cast</font>(<font color=blue>real</font>) meter));
</pre>
<br><br>
</dd>
<dt><big><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (is(Unqual!T == RTQuantity));
<br><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="opUnary"></a>const auto <u>opUnary</u>(string op)() if (op == "+" || op == "-");
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; op == "*");
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; op == "/");
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opEquals"></a>const bool <u>opEquals</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opEquals"></a>const bool <u>opEquals</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="opCmp"></a>const int <u>opCmp</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opCmp"></a>const int <u>opCmp</u>(T)(T <i>other</i>) if (isNumeric!T);
</big></dt>
<dd>Overloaded operators.
 Only dimensionally correct operations will compile.<br><br>

</dd>
<dt><big><a name="toString"></a>const string <u>toString</u>();
</big></dt>
<dd>Returns the default string representation of the quantity.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> inch = qty!<font color=red>"2.54 cm"</font>;
<font color=blue>assert</font>(inch.<u>toString</u> == <font color=red>"0.0254 m"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="toString"></a>const string <u>toString</u>(string <i>fmt</i>, SymbolList <i>symbolList</i> = SymbolList.defaultList);
<br><a name="toString"></a>const string <u>toString</u>(string fmt)();
</big></dt>
<dd>Returns a formatted string from the quantity.
<br><br>
The format string must be formed of a format specifier for the numeric value
    (e.g %s, %g, %.2f, etc.), followed by a unit. The whitespace between the
    format specifier and the unit is not significant.
<br><br>

    The unit present in the format is parsed each time the function is called, in
    order to calculate the value. If this quantity can be known at runtime,
    the template version of this function is more efficient, with the counterpart
    that it can only operate on SI units.<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> inch = qty!<font color=red>"2.54 cm"</font>;

<font color=green>// Format parsed at runtime
</font><font color=blue>assert</font>(inch.<u>toString</u>(<font color=red>"%s cm"</font>) == <font color=red>"2.54 cm"</font>);
<font color=blue>assert</font>(inch.<u>toString</u>(<font color=red>"%.2f mm"</font>) == <font color=red>"25.40 mm"</font>);

<font color=green>// Format parsed at compile-time
</font><font color=blue>assert</font>(inch.<u>toString</u>!<font color=red>"%s cm"</font> == <font color=red>"2.54 cm"</font>);
<font color=blue>assert</font>(inch.<u>toString</u>!<font color=red>"%.2f mm"</font> == <font color=red>"25.40 mm"</font>);
</pre>
<br><br></dd>
</dl>
</dd>
<dt><big><a name="isQuantity"></a>template <u>isQuantity</u>(T)</big></dt>
<dd>Tests whether T is a quantity type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!Time);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!(QuantityType!meter));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>isQuantity</u>!<font color=blue>real</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="unit"></a>template <u>unit</u>(string symbol, N = real)</big></dt>
<dd>Creates a new monodimensional <u>unit</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> euro = <u>unit</u>!<font color=red>"€"</font>;
<font color=blue>static</font> <font color=blue>assert</font>(isQuantity!(<font color=blue>typeof</font>(euro)));
<font color=blue>enum</font> dollar = euro / 1.35;
<font color=blue>assert</font>((1.35 * dollar).value(euro).approxEqual(1));
</pre>
<br><br>
</dd>
<dt><big><a name="square"></a>auto <u>square</u>(U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="cubic"></a>auto <u>cubic</u>(U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="pow"></a>auto <u>pow</u>(int n, U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="sqrt"></a>auto <u>sqrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="cbrt"></a>auto <u>cbrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="nthRoot"></a>auto <u>nthRoot</u>(int n, Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>Transforms a quantity/unit.<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> surface = 25 * square(meter);
<font color=blue>auto</font> side = sqrt(surface);
<font color=blue>assert</font>(side.value(meter).approxEqual(5));

<font color=blue>auto</font> volume = 27 * liter;
side = cbrt(volume);
<font color=blue>assert</font>(side.value(deci(meter)).approxEqual(3));
</pre>
<br><br></dd>
<dt><big><a name="abs"></a>Q <u>abs</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>Returns the absolute value of a quantity<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> deltaT = -10 * second;
<font color=blue>assert</font>(<u>abs</u>(deltaT) == 10 * second);
</pre>
<br><br>
</dd>
<dt><big><a name="QuantityType"></a>template <u>QuantityType</u>(alias unit, N = real) if (isQuantity!(typeof(unit)))</big></dt>
<dd>Returns the quantity type of a unit<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Mass = <u>QuantityType</u>!kilogram;
Mass mass = 15 * ton;

<font color=blue>alias</font> Surface = <u>QuantityType</u>!(square(meter), <font color=blue>float</font>);
<font color=blue>assert</font>(<font color=blue>is</font>(Surface.valueType == <font color=blue>float</font>));
Surface s = 4 * square(meter);
</pre>
<br><br>
</dd>
<dt><big><a name="Store"></a>template <u>Store</u>(Q, N) if (isQuantity!Q)</big></dt>
<dd>The type of a quantity where the payload is stored as another numeric type.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> TimeF = <u>Store</u>!(Time, <font color=blue>float</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="AreConsistent"></a>template <u>AreConsistent</u>(Q1, Q2) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)</big></dt>
<dd>Check that two quantity types are dimensionally consistent<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Speed = QuantityType!(meter/second);
<font color=blue>alias</font> Velocity = QuantityType!((1/second * meter));
<font color=blue>static</font> <font color=blue>assert</font>(<u>AreConsistent</u>!(Speed, Velocity));
</pre>
<br><br>
</dd>
<dt><big><a name="Inverse"></a>template <u>Inverse</u>(Q, N = real) if (isQuantity!Q)<br><a name="Product"></a>template <u>Product</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Quotient"></a>template <u>Quotient</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Square"></a>template <u>Square</u>(Q, N = real) if (isQuantity!Q)<br><a name="Cubic"></a>template <u>Cubic</u>(Q, N = real) if (isQuantity!Q)</big></dt>
<dd>Utility templates to manipulate quantity types<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Inverse!Time == Frequency));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Product!(Power, Time) == Energy));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Quotient!(Length, Time) == Speed)); 
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Square!Length == Area));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<u>Cubic</u>!Length == Volume));
<font color=blue>static</font> <font color=blue>assert</font>(AreConsistent!(Product!(Inverse!Time, Length), Speed));
</pre>
<br><br></dd>
<dt><big><a name="DimensionException"></a>class <u>DimensionException</u>: object.Exception;
</big></dt>
<dd>Exception thrown when operating on two units that are not interconvertible.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013, Nicolas Sicard
</small>
        </body></html>
