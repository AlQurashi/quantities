<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.base</title>
        </head><body>
        <h1>quantities.base</h1>
        <!-- Generated by Ddoc from source/quantities/base.d -->
This module defines the <u>base</u> types for unit and quantity handling.
<br><br>
Each  quantity can  be represented  as the  product  of a  number and  a set  of
dimensions,  and  the struct  Quantity  has  this  role.  The number  is  stored
internally as  a member of type  N, which is  enforced to be a  built-in numeric
type  (isNumeric!N is  <b>true</b>). The  dimensions are  stored as  template parameter
list (Dim)  in the  form of a  sequence of string  symbols and  integral powers.
Dimensionless  quantities have  an  empty  Dim. For  instance  length and  speed
quantities can be stored as:
<pre class="d_code"><font color=blue>alias</font> Length = Quantity!(<font color=blue>real</font>, <font color=red>"L"</font>, 1);
<font color=blue>alias</font> Speed  = Quantity!(<font color=blue>real</font>, <font color=red>"L"</font>, 1, <font color=red>"T"</font>, -1);
</pre>
where "L" is the symbol for the length  dimension, "T" is the symbol of the time
dimensions,  and  1   and  -1  are  the  powers  of   those  dimensions  in  the
representation of the quantity.
<br><br>

The main  quantities compliant with the  international system of units  (SI) are
predefined  in  the module  quantities.si.  In  the  same  way, units  are  just
instances of  a Quantity struct  where the number is  1 and the  dimensions only
contain  one  symbol,  with  the  power  1. For  instance,  the  meter  unit  is
predefined as something equivalent to:
<pre class="d_code"><font color=blue>enum</font> meter = Quantity!(<font color=blue>real</font>, <font color=red>"L"</font>, 1)(1.0);
</pre>
(note that  the constructor  used here  has the  package access  protection: new
units should be defined with the unit template of this module).
<br><br>

Any quantity can be expressed as the product  of a number (<i>n</i>) and a unit of
the right dimensions (<i>U</i>). For instance:
<pre class="d_code"><font color=blue>auto</font> size = 9.5 * meter;
<font color=blue>auto</font> time = 120 * milli(second);
</pre>
The unit  <i>U</i>  is not  actually stored along  with the  number in  a Quantity
struct,  only the  dimensions are.  This  is because  the same  quantity can  be
expressed in an  infinity of different units.  The value of <i>n</i>  is stored as
if the quantity was  expressed in the <u>base</u> units of the  same dimemsions. In the
example above,  <i>n</i> = 9.5  for the variable size  and <i>n</i> =  0.120 for the
variable time.
<br><br>

The  value method  can  be used  to  extract the  number  <i>n</i>  as  if it  was
expressed in  any possible  unit. The user  must pass this  unit to  the method.
This way, the user makes it clear in which unit the value was expressed.
<pre class="d_code"><font color=blue>auto</font> size = 9.5 * meter;
<font color=blue>auto</font> valueMeter      = size.value(meter);        <font color=green>// valueMeter == 9.5
</font><font color=blue>auto</font> valueCentimeter = size.value(centi(meter)); <font color=green>// valueCentimeter == 950
</font></pre>
Arithmetic operators (+ - * /),  as well as assignment and comparison operators,
are  defined when  the  operations are  dimensionally  consistent, otherwise  an
error occurs at compile-time:
<pre class="d_code"><font color=blue>auto</font> time = 2 * hour + 17 * minute;
<font color=blue>auto</font> frequency = time / second;
time = time + 2 * meter; <font color=green>// Compilation error
</font></pre>
Any kind  of quantities  and units  can be  defined with  this module,  not just
those  from the  SI. The  SI quantities  and units  are in  fact defined  in the
module quantities.si.  When a quantity  that is not  predefined has to  be used,
instead of instantiating the Quantity template  first, it is preferable to start
defining a new <u>base</u> unit (with only  one dimension) using the unit template, and
then the quantity type with the QuantityType template:
<pre class="d_code"><font color=blue>enum</font> euro = unit!<font color=red>"C"</font>; <font color=green>// C for currency
</font><font color=blue>alias</font> Currency = QuantityType!euro;
<font color=blue>assert</font>(<font color=blue>is</font>(Currency == Quantity!(<font color=blue>real</font>, <font color=red>"C"</font>, 1)));
</pre>
This means that all currencies will be defined with respect to euro.

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="Quantity"></a>struct <u>Quantity</u>(N, Dim...);
</big></dt>
<dd>A quantity that can be expressed as the product of a number and a set of dimensions.<br><br>

<dl><dt><big><a name="valueType"></a>alias <u>valueType</u> = N;
</big></dt>
<dd>The type of the underlying numeric value.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(meter.<u>valueType</u> == <font color=blue>real</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="dimensions"></a>alias <u>dimensions</u> = Dim;
</big></dt>
<dd>The dimension tuple of the quantity.<br><br>

</dd>
<dt><big><a name="baseUnit"></a>Quantity <u>baseUnit</u>();
</big></dt>
<dd>Gets the base unit of this quantity.<br><br>

</dd>
<dt><big><a name="value"></a>const N <u>value</u>(Q)(Q <i>target</i>) if (isQuantity!Q);
</big></dt>
<dd>Gets the value of this quantity expressed in the given target unit.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> time = 120 * minute;
<font color=blue>assert</font>(time.<u>value</u>(hour) == 2);
<font color=blue>assert</font>(time.<u>value</u>(minute) == 120);
</pre>
<br><br>
</dd>
<dt><big><a name="isConsistentWith"></a>const bool <u>isConsistentWith</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
</big></dt>
<dd>Tests wheter this quantity has the same dimensions as another one.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> nm = (1.4 * newton) * (0.5 * centi(meter));
<font color=blue>auto</font> kWh = (4000 * kilo(watt)) * (1200 * hour);
<font color=blue>assert</font>(nm.<u>isConsistentWith</u>(kWh)); <font color=green>// Energy in both cases
</font><font color=blue>assert</font>(!nm.<u>isConsistentWith</u>(second));
</pre>
<br><br>
</dd>
<dt><big><a name="opCast"></a>const Q <u>opCast</u>(Q)() if (isQuantity!Q);
</big></dt>
<dd>Cast a quantity to another quantity type with the same dimensions<br><br>

</dd>
<dt><big><a name="opCast"></a>const T <u>opCast</u>(T)() if (!isQuantity!T);
</big></dt>
<dd>Cast a dimensionless quantity to a numeric type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> proportion = 12 * gram / (4.5 * kilogram);
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(QuantityType!proportion == Dimensionless));
<font color=blue>auto</font> prop = <font color=blue>cast</font>(<font color=blue>real</font>) proportion;

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <font color=blue>cast</font>(<font color=blue>real</font>) meter));
</pre>
<br><br>
</dd>
<dt><big><a name="opAssign"></a>void <u>opAssign</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (!isQuantity!T);
<br><a name="opUnary"></a>const auto <u>opUnary</u>(string op)() if (op == "+" || op == "-");
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; op == "*");
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "/" || op == "%"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (!isQuantity!T &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="opEquals"></a>const bool <u>opEquals</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br><a name="opEquals"></a>const bool <u>opEquals</u>(T)(T <i>other</i>) if (!isQuantity!T);
<br><a name="opCmp"></a>const int <u>opCmp</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br><a name="opCmp"></a>const int <u>opCmp</u>(T)(T <i>other</i>) if (!isQuantity!T);
</big></dt>
<dd>Overloaded operators.
 Only dimensionally correct operations will compile.<br><br>

</dd>
<dt><big><a name="toString"></a>const string <u>toString</u>();
</big></dt>
<dd>Returns the default string representation of the quantity.
<br><br>
By default, a quantity is represented as a string by a number
    followed by the set of dimensions between brackets.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> inch = 2.54 * centi(meter);
<font color=blue>assert</font>(inch.<u>toString</u> == <font color=red>"0.0254 [L]"</font>, inch.<u>toString</u>);
</pre>
<br><br>
</dd>
</dl>
</dd>
<dt><big><a name="isQuantity"></a>template <u>isQuantity</u>(T)</big></dt>
<dd>Tests whether T is a quantity type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!Time);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!(QuantityType!meter));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>isQuantity</u>!<font color=blue>real</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="unit"></a>template <u>unit</u>(string symbol, N = real)</big></dt>
<dd>Creates a new monodimensional <u>unit</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> euro = <u>unit</u>!<font color=red>"C"</font>; <font color=green>// C for Currency
</font><font color=blue>static</font> <font color=blue>assert</font>(isQuantity!(<font color=blue>typeof</font>(euro)));
<font color=blue>enum</font> dollar = euro / 1.35;
<font color=blue>assert</font>((1.35 * dollar).value(euro).approxEqual(1));
</pre>
<br><br>
</dd>
<dt><big><a name="QuantityType"></a>template <u>QuantityType</u>(alias unit) if (isQuantity!(typeof(unit)))</big></dt>
<dd>Returns the quantity type of a unit<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Mass = <u>QuantityType</u>!kilogram;
Mass mass = 15 * ton;
</pre>
<br><br>
</dd>
<dt><big><a name="Store"></a>template <u>Store</u>(Q, N) if (isQuantity!Q &amp;&amp; isNumberLike!N)</big></dt>
<dd>Creates a new quantity type where the payload is stored as another numeric type.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> TimeF = <u>Store</u>!(Time, <font color=blue>float</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="store"></a>auto <u>store</u>(T, Q)(Q <i>quantity</i>, T delegate(Q.valueType) <i>convertDelegate</i> = (x) =&gt; cast(T)x) if (!isQuantity!T &amp;&amp; isQuantity!Q);
</big></dt>
<dd>Returns a new quantity where the value is stored in a field of type T.
<br><br>
By default, the value is converted to type T using a cast.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> sizeF = meter.<u>store</u>!<font color=blue>float</font>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(sizeF.valueType == <font color=blue>float</font>));
<font color=blue>auto</font> sizeI = meter.<u>store</u>!<font color=blue>ulong</font>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(sizeI.valueType == <font color=blue>ulong</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="AreConsistent"></a>template <u>AreConsistent</u>(Q1, Q2) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)</big></dt>
<dd>Check that two quantity types are dimensionally consistent.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Speed = QuantityType!(meter/second);
<font color=blue>alias</font> Velocity = QuantityType!((1/second * meter));
<font color=blue>static</font> <font color=blue>assert</font>(<u>AreConsistent</u>!(Speed, Velocity));
</pre>
<br><br>
</dd>
<dt><big><a name="prefix"></a>template <u>prefix</u>(alias factor)</big></dt>
<dd>Creates a new <u>prefix</u> function that mutlpy a Quantity by factor factor.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> milli = <u>prefix</u>!1e-3;
<font color=blue>assert</font>(milli(meter).value(meter).approxEqual(1e-3));
</pre>
<br><br>
</dd>
<dt><big><a name="DimensionException"></a>class <u>DimensionException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when operating on two units that are not interconvertible.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2014, Nicolas Sicard
</small>
        </body></html>
