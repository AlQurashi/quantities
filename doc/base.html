<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.base</title>
        </head><body>
        <h1>quantities.base</h1>
        <!-- Generated by Ddoc from source/quantities/base.d -->
This module defines the <u>base</u> types for unit and quantity handling.
<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="Quantity"></a>struct <u>Quantity</u>(N, Dim...);
</big></dt>
<dd>A quantity which holds a value and some dimensions.
<br><br>
The value is stored internally as a field of type N.
A dimensionless quantity can be cast to a builtin numeric type.
<br><br>

Arithmetic operators (+ - * /), as well as assignment and comparison operators,
are defined when the operations are dimensionally correct, otherwise an error
occurs at compile-time.<br><br>

<dl><dt><big><a name="valueType"></a>alias <u>valueType</u> = N;
</big></dt>
<dd>The type of the underlying numeric value.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(meter.<u>valueType</u> == <font color=blue>real</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="dimensions"></a>alias <u>dimensions</u> = Dim;
</big></dt>
<dd>The dimension tuple of the quantity.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(meter.<u>dimensions</u> == TypeTuple!(<font color=red>"m"</font>, 1,));
<font color=blue>static</font> <font color=blue>assert</font>(katal.<u>dimensions</u> == TypeTuple!(<font color=red>"mol"</font>, 1, <font color=red>"s"</font>, -1));
<font color=blue>static</font> <font color=blue>assert</font>(volt.<u>dimensions</u>  == TypeTuple!(<font color=red>"kg"</font>, 1, <font color=red>"m"</font>, 2, <font color=red>"s"</font>, -3, <font color=red>"A"</font>, -1));
</pre>
<br><br>
</dd>
<dt><big><a name="this"></a> this(Q)(Q <i>other</i>) if (isQuantity!Q);
</big></dt>
<dd>Creates a new quantity from another one with the same dimensions<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> size = Length(42 * kilo(meter));
</pre>
<br><br>
</dd>
<dt><big><a name="this"></a> this(T)(T <i>other</i>) if (is(Unqual!T == RTQuantity));
</big></dt>
<dd>Creates a new quantity from a runtime-parsed one<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> size = Length(parseQuantity(<font color=red>"42 km"</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="this"></a> this(T)(T <i>value</i>) if (isNumeric!T &amp;&amp; Dim.length == 0);
</big></dt>
<dd>Creates a new dimensionless quantity from a scalar value<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.math : PI;

Angle angle = PI / 2;
<font color=blue>assert</font>(angle.value(degreeOfAngle) == 90);
</pre>
<br><br>
</dd>
<dt><big><a name="rawValue"></a>const N <u>rawValue</u>();
</big></dt>
<dd>Gets the internal scalar value of this quantity.
<br><br>
The returned number is the value of the quantity when it is
    expressed in the corresponding base unit.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> time = 10 * minute;
<font color=blue>assert</font>(time.<u>rawValue</u> == 600); <font color=green>// There are 600 s in 10 min
</font></pre>
<br><br>
</dd>
<dt><big><a name="value"></a>const N <u>value</u>(Q)(Q <i>target</i>) if (isQuantity!Q);
</big></dt>
<dd>Gets the scalar value of this quantity expressed in the given target unit.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> time = 120 * minute;
<font color=blue>assert</font>(time.<u>value</u>(hour) == 2);
<font color=blue>assert</font>(time.<u>value</u>(minute) == 120);
<font color=blue>assert</font>(time.<u>value</u>(second) == 7200);
</pre>
<br><br>
</dd>
<dt><big><a name="isConsistentWith"></a>const bool <u>isConsistentWith</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br><a name="isConsistentWith"></a>const bool <u>isConsistentWith</u>(S)(S <i>str</i>) if (isSomeString!S);
</big></dt>
<dd>Tests wheter this quantity has the same dimensions<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> nm = (1.4 * newton) * (0.5 * centi(meter));
<font color=blue>auto</font> kwh = (4000 * kilo(watt)) * (1200 * hour);
<font color=blue>assert</font>(nm.<u>isConsistentWith</u>(kwh)); <font color=green>// Energy in both cases
</font><font color=blue>assert</font>(!nm.<u>isConsistentWith</u>(second));
</pre>
<br><br></dd>
<dt><big><a name="store"></a>const auto <u>store</u>(T)() if (isNumeric!T);
</big></dt>
<dd>Returns a new quantity where the value is stored in a field of type T.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> size = meter.<u>store</u>!<font color=blue>float</font>;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(size.valueType == <font color=blue>float</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="opCast"></a>const Q <u>opCast</u>(Q)() if (isQuantity!Q);
</big></dt>
<dd>Cast a quantity to another quantity type with the same dimensions<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Length = QuantityType!(meter, <font color=blue>float</font>);
<font color=blue>auto</font> m = <font color=blue>cast</font>(Length) meter;
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(meter.valueType == <font color=blue>real</font>));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(m.valueType == <font color=blue>float</font>));

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <font color=blue>cast</font>(Time) meter));
</pre>
<br><br>
</dd>
<dt><big><a name="opCast"></a>const T <u>opCast</u>(T)() if (isNumeric!T);
</big></dt>
<dd>Cast a dimensionless quantity to a scalar numeric type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> proportion = 12 * gram / (4.5 * kilogram);
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(QuantityType!proportion == Dimensionless));
<font color=blue>auto</font> prop = <font color=blue>cast</font>(<font color=blue>real</font>) proportion;

<font color=blue>static</font> <font color=blue>assert</font>(!<font color=blue>__traits</font>(compiles, <font color=blue>cast</font>(<font color=blue>real</font>) meter));
</pre>
<br><br>
</dd>
<dt><big><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (is(Unqual!T == RTQuantity));
<br><a name="opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="opUnary"></a>const auto <u>opUnary</u>(string op)() if (op == "+" || op == "-");
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opBinary"></a>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; op == "*");
<br><a name="opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; op == "/");
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isQuantity!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opOpAssign"></a>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/"));
<br><a name="opEquals"></a>const bool <u>opEquals</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opEquals"></a>const bool <u>opEquals</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="opCmp"></a>const int <u>opCmp</u>(T)(T <i>other</i>) if (isQuantity!T);
<br><a name="opCmp"></a>const int <u>opCmp</u>(T)(T <i>other</i>) if (isNumeric!T);
</big></dt>
<dd>Overloaded operators.
 Only dimensionally correct operations will compile.<br><br>

</dd>
<dt><big><a name="toString"></a>const void <u>toString</u>(scope void delegate(const(char)[]) <i>sink</i>);
</big></dt>
<dd>Returns a default string representation of the quantity.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="isQuantity"></a>template <u>isQuantity</u>(T)</big></dt>
<dd>Tests whether T is a quantity type<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!Time);
<font color=blue>static</font> <font color=blue>assert</font>(<u>isQuantity</u>!(QuantityType!meter));
<font color=blue>static</font> <font color=blue>assert</font>(!<u>isQuantity</u>!<font color=blue>real</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="unit"></a>template <u>unit</u>(string symbol, N = real)</big></dt>
<dd>Creates a new monodimensional <u>unit</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> euro = <u>unit</u>!<font color=red>"€"</font>;
<font color=blue>static</font> <font color=blue>assert</font>(isQuantity!(<font color=blue>typeof</font>(euro)));
<font color=blue>enum</font> dollar = euro / 1.35;
<font color=blue>assert</font>((1.35 * dollar).value(euro).approxEqual(1));
</pre>
<br><br>
</dd>
<dt><big><a name="square"></a>auto <u>square</u>(U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="cubic"></a>auto <u>cubic</u>(U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="pow"></a>auto <u>pow</u>(int n, U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="sqrt"></a>auto <u>sqrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="cbrt"></a>auto <u>cbrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="nthRoot"></a>auto <u>nthRoot</u>(int n, Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>Transforms a quantity/unit.<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> surface = 25 * square(meter);
<font color=blue>auto</font> side = sqrt(surface);
<font color=blue>assert</font>(side.value(meter).approxEqual(5));

<font color=blue>auto</font> volume = 27 * liter;
side = cbrt(volume);
<font color=blue>assert</font>(side.value(deci(meter)).approxEqual(3));
</pre>
<br><br></dd>
<dt><big><a name="abs"></a>Q <u>abs</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>Returns the absolute value of a quantity<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> deltaT = -10 * second;
<font color=blue>assert</font>(<u>abs</u>(deltaT) == 10 * second);
</pre>
<br><br>
</dd>
<dt><big><a name="QuantityType"></a>template <u>QuantityType</u>(alias unit, N = real) if (isQuantity!(typeof(unit)))</big></dt>
<dd>Returns the quantity type of a unit<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Mass = <u>QuantityType</u>!kilogram;
Mass mass = 15 * ton;

<font color=blue>alias</font> Surface = <u>QuantityType</u>!(square(meter), <font color=blue>float</font>);
<font color=blue>assert</font>(<font color=blue>is</font>(Surface.valueType == <font color=blue>float</font>));
Surface s = 4 * square(meter);
</pre>
<br><br>
</dd>
<dt><big><a name="Store"></a>template <u>Store</u>(Q, N) if (isQuantity!Q)</big></dt>
<dd>The type of a quantity where the payload is stored as another numeric type.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> TimeF = <u>Store</u>!(Time, <font color=blue>float</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="AreConsistent"></a>template <u>AreConsistent</u>(Q1, Q2) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)</big></dt>
<dd>Check that two quantity types are dimensionally consistent<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Speed = QuantityType!(meter/second);
<font color=blue>alias</font> Velocity = QuantityType!((1/second * meter));
<font color=blue>static</font> <font color=blue>assert</font>(<u>AreConsistent</u>!(Speed, Velocity));
</pre>
<br><br>
</dd>
<dt><big><a name="Inverse"></a>template <u>Inverse</u>(Q, N = real) if (isQuantity!Q)<br><a name="Product"></a>template <u>Product</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Quotient"></a>template <u>Quotient</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Square"></a>template <u>Square</u>(Q, N = real) if (isQuantity!Q)<br><a name="Cubic"></a>template <u>Cubic</u>(Q, N = real) if (isQuantity!Q)</big></dt>
<dd>Utility templates to manipulate quantity types<br><br>

<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Inverse!Time == Frequency));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Product!(Power, Time) == Energy));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Quotient!(Length, Time) == Speed)); 
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Square!Length == Area));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<u>Cubic</u>!Length == Volume));
<font color=blue>static</font> <font color=blue>assert</font>(AreConsistent!(Product!(Inverse!Time, Length), Speed));
</pre>
<br><br></dd>
<dt><big><a name="DimensionException"></a>class <u>DimensionException</u>: object.Exception;
</big></dt>
<dd>Exception thrown when operating on two units that are not interconvertible.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013, Nicolas Sicard
</small>
        </body></html>
