<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.math</title>
        </head><body>
        <h1>quantities.math</h1>
        <!-- Generated by Ddoc from source/quantities/math.d -->
This module defines common <u>math</u> operations on quantities.
<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Standards:</b><br>
<a href="http://www.bipm.org/en/si/si_brochure/">http://www.bipm.org/en/si/si_brochure/</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="MathFunctions"></a>template <u>MathFunctions</u>(string module_ = "std.math")</big></dt>
<dd>Mixin template that introduces math functions operating on a quantity in the
current scope. Each function imports module_ internally. This module should
contain the math primitives that can operate on the quantities' value type, such
as sqrt, cbrt, pow and fabs.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> meter = unit!(<font color=red>"L"</font>);
<font color=blue>enum</font> liter = 0.001 * meter * meter * meter;

<font color=blue>mixin</font> <u>MathFunctions</u>!(<font color=red>"std.math"</font>);

<font color=blue>auto</font> surface = 25 * square(meter);
<font color=blue>auto</font> side = sqrt(surface);
<font color=blue>assert</font>(side.value(meter).approxEqual(5));

<font color=blue>auto</font> volume = 27 * liter;
side = cbrt(volume);
<font color=blue>assert</font>(side.value(meter).approxEqual(0.3));

<font color=blue>auto</font> delta = -10 * meter;
<font color=blue>assert</font>(abs(delta) == 10 * meter);
</pre>
<br><br>
<dl><dt><big><a name="cubic"></a>auto <u>cubic</u>(U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="pow"></a>auto <u>pow</u>(int n, U)(U <i>unit</i>) if (isQuantity!U);
<br><a name="sqrt"></a>auto <u>sqrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="cbrt"></a>auto <u>cbrt</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="nthRoot"></a>auto <u>nthRoot</u>(int n, Q)(Q <i>quantity</i>) if (isQuantity!Q);
<br><a name="abs"></a>Q <u>abs</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>ditto<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Inverse"></a>template <u>Inverse</u>(Q, N = real) if (isQuantity!Q)<br><a name="Product"></a>template <u>Product</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Quotient"></a>template <u>Quotient</u>(Q1, Q2, N = real) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)<br><a name="Square"></a>template <u>Square</u>(Q, N = real) if (isQuantity!Q)<br><a name="Cubic"></a>template <u>Cubic</u>(Q, N = real) if (isQuantity!Q)</big></dt>
<dd>Utility templates to manipulate quantity types.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> quantities.si;

<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Inverse!Time == Frequency));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Product!(Power, Time) == Energy));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Quotient!(Length, Time) == Speed));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(Square!Length == Area));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<u>Cubic</u>!Length == Volume));
<font color=blue>static</font> <font color=blue>assert</font>(AreConsistent!(Product!(Inverse!Time, Length), Speed));
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2014, Nicolas Sicard
</small>
        </body></html>
