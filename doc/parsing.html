<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.parsing</title>
        </head><body>
        <h1>quantities.parsing</h1>
        <!-- Generated by Ddoc from source/quantities/parsing.d -->
This module defines functions to parse units and quantities. The text
input is parsed according to the following grammar. For example:
<dl><dt>Prefixes and unit symbols must be joined:</dt>
    <dd>"1 mm" = 1 millimeter</dd>
    <dd>"1 m m" = 1 square meter</dd>
<br>
<dt>Standalone units are preferred over prefixed ones:</dt>
    <dd>"1 cd" = 1 candela, not 1 centiday</dd>
<br>
<dt>Powers of units:</dt>
    <dd>"1 m^2"</dd>
    <dd>"1 m²" <i>(superscript integer)</i></dd>
<br>
<dt>Multiplication of to units:</dt>
    <dd>"1 N m" <i>(whitespace)</i></dd>
    <dd>"1 N . m"</dd>
    <dd>"1 N ⋅ m" <i>(centered dot)</i></dd>
    <dd>"1 N * m"</dd>
    <dd>"1 N × m" <i>(times sign)</i></dd>
<br>
<dt>Division of to units:</dt>
    <dd>"1 mol / s"</dd>
    <dd>"1 mol ÷ s"</dd>
<br>
<dt>Grouping of units with parentheses:</dt>
    <dd>"1 kg/(m.s^2)" = 1 kg m⁻¹ s⁻²</dd>
</dl>
<br><br>
<b>Grammar:</b><br>
(whitespace not significant)
<dl><dt>Quantity:</dt>
    <dd>Units</dd>
    <dd>Number Units</dd>
<br>
<dt>Number:</dt>
    <dd><i>Numeric value parsed by std.conv.parse!real</i></dd>
<br>
<dt>Units:</dt>
    <dd>Unit</dd>
    <dd>Unit Units</dd>
    <dd>Unit Operator Units</dd>
<br>
<dt>Operator:</dt>
    <dd><b>*</b></dd>
    <dd><b>.</b></dd>
    <dd><b>⋅</b></dd>
    <dd><b>×</b></dd>
    <dd><b>/</b></dd>
    <dd><b>÷</b></dd>
<br>
<dt>Unit:</dt>
    <dd>Base</dd>
    <dd>Base <b>^</b> Integer</dd>
    <dd>Base SupInteger</dd>
<br>
<dt>Base:</dt>
    <dd>Symbol</dd>
    <dd>Prefix Symbol</dd>
    <dd><b>(</b> Units <b>)</b></dd>
<br>
<dt>Symbol:</dt>
    <dd><i>The symbol of a valid unit</i></dd>
<br>
<dt>Prefix:</dt>
    <dd><i>The symbol of a valid prefix</i></dd>
<br>
<dt>Integer:</dt>
    <dd><i>Integer value parsed by std.conv.parse!int</i></dd>
<br>
<dt>SupInteger:</dt>
    <dd><i>Superscript version of Integer</i></dd>
</dl>

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="SymbolList"></a>struct <u>SymbolList</u>(N);
</big></dt>
<dd>Contains the symbols of the units and the prefixes that a parser can handle.<br><br>

<dl><dt><big><a name="addUnit"></a>void <u>addUnit</u>(Q)(string <i>symbol</i>, Q <i>unit</i>) if (isQuantity!Q);
</big></dt>
<dd>Adds (or replaces) a unit in the list<br><br>

</dd>
<dt><big><a name="addPrefix"></a>void <u>addPrefix</u>(N)(string <i>symbol</i>, N <i>factor</i>) if (isValue!N);
</big></dt>
<dd>Adds (or replaces) a prefix in the list<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="makeSymbolList"></a>SymbolList!N <u>makeSymbolList</u>(N, Sym...)(Sym <i>list</i>);
</big></dt>
<dd>Helps build a SymbolList at compile-time.
<br><br>
Use with the global addUnit and addPrefix functions.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> euro = unit!(<font color=red>"C"</font>, <font color=blue>double</font>);
<font color=blue>alias</font> Currency = QuantityType!euro;
<font color=blue>enum</font> dollar = 1.35 * euro;

<font color=blue>enum</font> symbolList = <u>makeSymbolList</u>!<font color=blue>double</font>(
	withUnit(<font color=red>"€"</font>, euro),
	withUnit(<font color=red>"$"</font>, dollar),
       withPrefix(<font color=red>"doz"</font>, 12)
);
</pre>
<br><br>
</dd>
<dt><big><a name="withUnit"></a>auto <u>withUnit</u>(Q)(string <i>symbol</i>, Q <i>unit</i>) if (isQuantity!Q);
</big></dt>
<dd>Creates a unit that can be added to a SymbolList via the SymbolList constuctor.<br><br>

</dd>
<dt><big><a name="withPrefix"></a>auto <u>withPrefix</u>(N)(string <i>symbol</i>, N <i>factor</i>) if (isValue!N);
</big></dt>
<dd>Creates a prefix that can be added to a SymbolList via the SymbolList constuctor.<br><br>

</dd>
<dt><big><a name="rtQuantityParser"></a>template <u>rtQuantityParser</u>(N, alias symbolList, alias parseFun = (ref string s) =&gt; parse!N(s), N one = 1)</big></dt>
<dd>Creates a runtime parser capable of working on user-defined units and prefixes.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>The type of the value type stored in the Quantity struct.</td></tr>
<tr><td>symbolList</td>
<td>A prefilled SymbolList struct that contains all units and prefixes.</td></tr>
<tr><td>parseFun</td>
<td>A function that can parse the beginning of a string to return a numeric value of type N.
        After this function returns, it must have consumed the numeric part and leave only the unit part.</td></tr>
<tr><td>one</td>
<td>The value of type N that is equivalent to 1.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> std.bigint;

<font color=blue>enum</font> bit = unit!(<font color=red>"bit"</font>, BigInt);
<font color=blue>alias</font> BinarySize = QuantityType!bit;

SymbolList!BigInt symbolList;
symbolList.addUnit(<font color=red>"bit"</font>, bit);
symbolList.addPrefix(<font color=red>"or"</font>, BigInt(<font color=red>"1234567890987654321"</font>));

<font color=blue>static</font> BigInt parseFun(<font color=blue>ref</font> string input)
{
	<font color=blue>import</font> std.exception, std.regex;
	<font color=blue>enum</font> rgx = ctRegex!<font color=red>`^(\d*)\s*(.*)$`</font>;
	<font color=blue>auto</font> m = enforce(match(input, rgx));
	input = m.captures[2];
	<font color=blue>return</font> BigInt(m.captures[1]);
}

<font color=blue>alias</font> parse = <u>rtQuantityParser</u>!(BigInt, symbolList, parseFun, BigInt(1));

<font color=blue>auto</font> foo = BigInt(<font color=red>"1234567890987654300"</font>) * bit;
foo += 21 * bit;
<font color=blue>assert</font>(foo == parse!BinarySize(<font color=red>"1 orbit"</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="ctQuantityParser"></a>template <u>ctQuantityParser</u>(N, alias symbolList, alias parseFun = (ref string s) =&gt; parse!N(s), N one = 1)</big></dt>
<dd>Creates a compile-time parser capable of working on user-defined units and prefixes.
<br><br>
Contrary to a runtime parser, a compile-time parser infers the type of the parsed quantity
automatically from the dimensions of its components.

<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>The type of the value type stored in the Quantity struct.</td></tr>
<tr><td>symbolList</td>
<td>A prefilled SymbolList struct that contains all units and prefixes.</td></tr>
<tr><td>parseFun</td>
<td>A function that can parse the beginning of a string to return a numeric value of type N.
        After this function returns, it must have consumed the numeric part and leave only the unit part.</td></tr>
<tr><td>one</td>
<td>The value of type N that is equivalent to 1.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> bit = unit!(<font color=red>"bit"</font>, <font color=blue>ulong</font>);
<font color=blue>alias</font> BinarySize = QuantityType!bit;
<font color=blue>enum</font> byte_ = 8 * bit;

<font color=blue>enum</font> symbolList = makeSymbolList!<font color=blue>ulong</font>(
	withUnit(<font color=red>"bit"</font>, bit),
	withUnit(<font color=red>"B"</font>, byte_),
	withPrefix(<font color=red>"hob"</font>, 7)
);

<font color=blue>alias</font> sz = <u>ctQuantityParser</u>!(<font color=blue>ulong</font>, symbolList);

<font color=blue>assert</font>(sz!<font color=red>"1 hobbit"</font>.value(bit) == 7);
</pre>
<br><br>
</dd>
<dt><big><a name="ParsingException"></a>class <u>ParsingException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when parsing encounters an unexpected token.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2014, Nicolas Sicard
</small>
        </body></html>
