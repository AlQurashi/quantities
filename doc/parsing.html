<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.parsing</title>
        </head><body>
        <h1>quantities.parsing</h1>
        <!-- Generated by Ddoc from source/quantities/parsing.d -->
This module defines functions to parse units and quantities. The text
input is parsed according to the following grammar. For example:
<dl><dt>Prefixes and unit symbols must be joined:</dt>
    <dd>"1 mm" = 1 millimeter</dd>
    <dd>"1 m m" = 1 square meter</dd>
<br>
<dt>Standalone units are preferred over prefixed ones:</dt>
    <dd>"1 cd" = 1 candela, not 1 centiday</dd>
<br>
<dt>Powers of units:</dt>
    <dd>"1 m^2"</dd>
    <dd>"1 m²" <i>(superscript integer)</i></dd>
<br>
<dt>Multiplication of to units:</dt>
    <dd>"1 N m" <i>(whitespace)</i></dd>
    <dd>"1 N . m"</dd>
    <dd>"1 N ⋅ m" <i>(centered dot)</i></dd>
    <dd>"1 N * m"</dd>
    <dd>"1 N × m" <i>(times sign)</i></dd>
<br>
<dt>Division of to units:</dt>
    <dd>"1 mol / s"</dd>
    <dd>"1 mol ÷ s"</dd>
<br>
<dt>Grouping of units with parentheses:</dt>
    <dd>"1 kg/(m.s^2)" = 1 kg m⁻¹ s⁻²</dd>
</dl>
<br><br>
<b>Grammar:</b><br>
(whitespace not significant)
<dl><dt>Quantity:</dt>
    <dd>Units</dd>
    <dd>Number Units</dd>
<br>
<dt>Number:</dt>
    <dd><i>Numeric value parsed by std.conv.parse!real</i></dd>
<br>
<dt>Units:</dt>
    <dd>Unit</dd>
    <dd>Unit Units</dd>
    <dd>Unit Operator Units</dd>
<br>
<dt>Operator:</dt>
    <dd><b>*</b></dd>
    <dd><b>.</b></dd>
    <dd><b>⋅</b></dd>
    <dd><b>×</b></dd>
    <dd><b>/</b></dd>
    <dd><b>÷</b></dd>
<br>
<dt>Unit:</dt>
    <dd>Base</dd>
    <dd>Base <b>^</b> Integer</dd>
    <dd>Base SupInteger</dd>
<br>
<dt>Base:</dt>
    <dd>Symbol</dd>
    <dd>Prefix Symbol</dd>
    <dd><b>(</b> Units <b>)</b></dd>
<br>
<dt>Symbol:</dt>
    <dd><i>The symbol of a valid unit</i></dd>
<br>
<dt>Prefix:</dt>
    <dd><i>The symbol of a valid prefix</i></dd>
<br>
<dt>Integer:</dt>
    <dd><i>Integer value parsed by std.conv.parse!int</i></dd>
<br>
<dt>SupInteger:</dt>
    <dd><i>Superscript version of Integer</i></dd>
</dl>

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="SymbolList"></a>struct <u>SymbolList</u>(N);
</big></dt>
<dd>Contains the symbols of the units and the prefixes that a parser can handle.<br><br>

</dd>
<dt><big><a name="addUnit"></a>auto <u>addUnit</u>(Q)(string <i>symbol</i>, Q <i>unit</i>) if (isQuantity!Q);
</big></dt>
<dd>Creates a unit that can be added to a SymbolList via the makeSymbolList function.<br><br>

</dd>
<dt><big><a name="addPrefix"></a>auto <u>addPrefix</u>(N)(string <i>symbol</i>, N <i>factor</i>) if (isValue!N);
</big></dt>
<dd>Creates a prefix that can be added to a SymbolList via the makeSymbolList function.<br><br>

</dd>
<dt><big><a name="makeSymbolList"></a>SymbolList!N <u>makeSymbolList</u>(N, Sym...)(Sym <i>list</i>);
</big></dt>
<dd>Builds a SymbolList from a list of units and prefixes
<br><br>
<b>See:</b><br>
Example of the parseQuantity function.<br><br>

</dd>
<dt><big><a name="parseQuantity"></a>auto <u>parseQuantity</u>(Q, alias parseFun = (ref string s) =&gt; parse!(Q.valueType)(s), S, SL)(S <i>text</i>, auto ref SL <i>symbolList</i>) if (isQuantity!Q);
</big></dt>
<dd>Parses text for a quantity of type Q at runtime.
<br><br>
<b>Params:</b><br>
<table><tr><td>S text</td>
<td>The string to parse.</td></tr>
<tr><td>SL symbolList</td>
<td>A prefilled SymbolList struct that contains all units and prefixes.</td></tr>
<tr><td>Q</td>
<td>The type of the quantity that the function should return.</td></tr>
<tr><td>parseFun</td>
<td>A function that can parse the beginning of text for a numeric value.
        This function must consume the parsed numeric value and leave only a unit to parse.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> bit = unit!(<font color=red>"bit"</font>, <font color=blue>ulong</font>);
<font color=blue>alias</font> BinarySize = QuantityType!bit;
<font color=blue>enum</font> byte_ = 8 * bit;

<font color=blue>auto</font> symbolList = makeSymbolList!<font color=blue>ulong</font>(
    addUnit(<font color=red>"bit"</font>, bit),
    addUnit(<font color=red>"B"</font>, byte_),
    addPrefix(<font color=red>"hob"</font>, 7)
);

<font color=blue>auto</font> height = <u>parseQuantity</u>!BinarySize(<font color=red>"1 hobbit"</font>, symbolList);
<font color=blue>assert</font>(height.value(bit) == 7);
</pre>
<br><br>
</dd>
<dt><big><a name="ctQuantityParser"></a>template <u>ctQuantityParser</u>(N, alias symbolList, alias parseFun)</big></dt>
<dd>Creates a compile-time parser capable of working on user-defined units and prefixes.
<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>The type of the value type stored in the Quantity struct.</td></tr>
<tr><td>symbolList</td>
<td>A prefilled SymbolList struct that contains all units and prefixes.</td></tr>
<tr><td>parseFun</td>
<td>A function that can parse the beginning of text for a numeric value.
        This function must consume the parsed numeric value and leave only a unit to parse.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> bit = unit!<font color=red>"bit"</font>;
<font color=blue>enum</font> byte_ = 8 * bit;
<font color=blue>enum</font> symbolList = makeSymbolList!<font color=blue>real</font>(
    addUnit(<font color=red>"bit"</font>, bit),
    addUnit(<font color=red>"B"</font>, byte_),
    addPrefix(<font color=red>"hob"</font>, 7)
);

<font color=blue>alias</font> sz = <u>ctQuantityParser</u>!(<font color=blue>real</font>, symbolList, std.conv.parse!(<font color=blue>real</font>, string));

<font color=blue>auto</font> height = sz!<font color=red>"1 hobbit"</font>;
<font color=blue>assert</font>(height.value(sz!<font color=red>"bit"</font>) == 7);
</pre>
<br><br>
</dd>
<dt><big><a name="ParsingException"></a>class <u>ParsingException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when parsing encounters an unexpected token.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2014, Nicolas Sicard
</small>
        </body></html>
