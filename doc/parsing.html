<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.parsing</title>
        </head><body>
        <h1>quantities.parsing</h1>
        <!-- Generated by Ddoc from source/quantities/parsing.d -->
This module defines functions to parse units and quantities. The text
input is parsed according to the following grammar. For example:
<dl><dt>Prefixes and unit symbols must be joined:</dt>
    <dd>"1 mm" = 1 millimeter</dd>
    <dd>"1 m m" = 1 square meter</dd>
<br>
<dt>Standalone units are preferred over prefixed ones:</dt>
    <dd>"1 cd" = 1 candela, not 1 centiday</dd>
<br>
<dt>Powers of units:</dt>
    <dd>"1 m^2"</dd>
    <dd>"1 m²" <i>(superscript integer)</i></dd>
<br>
<dt>Multiplication of to units:</dt>
    <dd>"1 N m" <i>(whitespace)</i></dd>
    <dd>"1 N . m"</dd>
    <dd>"1 N ⋅ m" <i>(centered dot)</i></dd>
    <dd>"1 N * m"</dd>
    <dd>"1 N × m" <i>(times sign)</i></dd>
<br>
<dt>Division of to units:</dt>
    <dd>"1 mol / s"</dd>
    <dd>"1 mol ÷ s"</dd>
<br>
<dt>Grouping of units with parentheses:</dt>
    <dd>"1 kg/(m.s^2)" = 1 kg m⁻¹ s⁻²</dd>
</dl>
<br><br>
<b>Grammar:</b><br>
(whitespace not significant)
<dl><dt>Quantity:</dt>
    <dd>Units</dd>
    <dd>Number Units</dd>
<br>
<dt>Number:</dt>
    <dd><i>Numeric value parsed by std.conv.parse!real</i></dd>
<br>
<dt>Units:</dt>
    <dd>Unit</dd>
    <dd>Unit Units</dd>
    <dd>Unit Operator Units</dd>
<br>
<dt>Operator:</dt>
    <dd><b>*</b></dd>
    <dd><b>.</b></dd>
    <dd><b>⋅</b></dd>
    <dd><b>×</b></dd>
    <dd><b>/</b></dd>
    <dd><b>÷</b></dd>
<br>
<dt>Unit:</dt>
    <dd>Base</dd>
    <dd>Base <b>^</b> Integer</dd>
    <dd>Base SupInteger</dd>
<br>
<dt>Base:</dt>
    <dd>Symbol</dd>
    <dd>Prefix Symbol</dd>
    <dd><b>(</b> Units <b>)</b></dd>
<br>
<dt>Symbol:</dt>
    <dd><i>The symbol of a valid unit</i></dd>
<br>
<dt>Prefix:</dt>
    <dd><i>The symbol of a valid prefix</i></dd>
<br>
<dt>Integer:</dt>
    <dd><i>Integer value parsed by std.conv.parse!int</i></dd>
<br>
<dt>SupInteger:</dt>
    <dd><i>Superscript version of Integer</i></dd>
</dl>

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="qty"></a>template <u>qty</u>(string str, N = real)</big></dt>
<dd>Parses a string for a quantity/unit at compile time.
<br><br>
Currently, only official SI units and prefixes can be parsed. These
are the units and prefixes available from <u>defaultSymbolList</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> min = <u>qty</u>!<font color=red>"min"</font>;
<font color=blue>enum</font> inch = <u>qty</u>!<font color=red>"2.54 cm"</font>;
</pre>
<br><br>
</dd>
<dt><big><a name="parseQuantity"></a>RTQuantity <u>parseQuantity</u>(S)(S <i>text</i>, SymbolList <i>symbolList</i> = defaultSymbolList());
</big></dt>
<dd>Parses text for a unit or a quantity at runtime.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Concentration = QuantityType!(mole/cubic(meter));
<font color=blue>alias</font> Length = QuantityType!meter;

<font color=green>// Parse a concentration value
</font>Concentration c = <u>parseQuantity</u>(<font color=red>"11.2 µmol/L"</font>);
<font color=blue>assert</font>(c.value(nano(mole)/liter).approxEqual(11200));

<font color=green>// Below, 'second' is only a hint for dimensional analysis
</font>QuantityType!second t = <u>parseQuantity</u>(<font color=red>"90 min"</font>);
<font color=blue>assert</font>(t == 90 * minute);
t = <u>parseQuantity</u>(<font color=red>"h"</font>);
<font color=blue>assert</font>(t == 1 * hour);

<font color=green>// User-defined unit
</font><font color=blue>auto</font> symbols = defaultSymbolList();
symbols.unitSymbols[<font color=red>"in"</font>] = toRuntime(2.54 * centi(meter));
Length len = <u>parseQuantity</u>(<font color=red>"17 in"</font>, symbols);
<font color=blue>assert</font>(len.value(centi(meter)).approxEqual(17 * 2.54));

<font color=green>// User-defined symbols
</font><font color=blue>auto</font> byte_ = unit!(<font color=red>"B"</font>);
SymbolList binSymbols;
binSymbols.unitSymbols[<font color=red>"B"</font>] = byte_.toRuntime;
binSymbols.prefixSymbols[<font color=red>"Ki"</font>] = 2^^10;
binSymbols.prefixSymbols[<font color=red>"Mi"</font>] = 2^^20;
<font color=green>// ...
</font>QuantityType!byte_ fileLength = <u>parseQuantity</u>(<font color=red>"1.0 MiB"</font>, binSymbols);
<font color=blue>assert</font>(fileLength.value(byte_).approxEqual(1_048_576));
</pre>
<br><br>
</dd>
<dt><big><a name="SymbolList"></a>struct <u>SymbolList</u>;
</big></dt>
<dd>This struct contains the symbols of the units and the prefixes
 that the parser can handle.<br><br>

<dl><dt><big><a name="SymbolList.unitSymbols"></a>RTQuantity[string] <u>unitSymbols</u>;
</big></dt>
<dd>An associative arrays of quantities (units) keyed by their symbol<br><br>

</dd>
<dt><big><a name="SymbolList.prefixSymbols"></a>real[string] <u>prefixSymbols</u>;
</big></dt>
<dd>An associative arrays of prefix factors keyed by their prefix symbol<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="defaultSymbolList"></a>SymbolList <u>defaultSymbolList</u>();
</big></dt>
<dd>Returns the default list, consisting of the main SI units and prefixes.<br><br>

</dd>
<dt><big><a name="convert"></a>real <u>convert</u>(S, U)(S <i>from</i>, U <i>target</i>) if (isSomeString!S &amp;&amp; isSomeString!U);
</big></dt>
<dd>Convert a quantity parsed from a string into target unit, also parsed from
a string.
<br><br>
<b>Parameters:</b><br>
from = A string representing the quantity to <u>convert</u>
  target = A string representing the target unit
<br><br>
<b>Returns:</b><br>
The conversion factor (a scalar value)<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> k = <u>convert</u>(<font color=red>"3 min"</font>, <font color=red>"s"</font>);
<font color=blue>assert</font>(k == 180);
</pre>
<br><br>
</dd>
<dt><big><a name="toRuntime"></a>RTQuantity <u>toRuntime</u>(Q)(Q <i>quantity</i>) if (isQuantity!Q);
</big></dt>
<dd>Convert a compile-time quantity to its runtime equivalent.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> distance = <u>toRuntime</u>(42 * kilo(meter));
<font color=blue>assert</font>(distance == parseQuantity(<font color=red>"42 km"</font>));
</pre>
<br><br>
</dd>
<dt><big><a name="RTQuantity"></a>struct <u>RTQuantity</u>;
</big></dt>
<dd>Holds a value and a dimensions for parsing<br><br>

</dd>
<dt><big><a name="ParsingException"></a>class <u>ParsingException</u>: object.Exception;
</big></dt>
<dd>Exception thrown when parsing encounters an unexpected token.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013, Nicolas Sicard
</small>
        </body></html>
