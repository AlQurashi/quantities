<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.parsing</title>
        </head><body>
        <h1>quantities.parsing</h1>
        <!-- Generated by Ddoc from source/quantities/parsing.d -->
This module defines functions to parse units and quantities. The text
input is parsed according to the following grammar. For example:
<dl><dt>Prefixes and unit symbols must be joined:</dt>
    <dd>"1 mm" = 1 millimeter</dd>
    <dd>"1 m m" = 1 square meter</dd>
<br>
<dt>Standalone units are preferred over prefixed ones:</dt>
    <dd>"1 cd" = 1 candela, not 1 centiday</dd>
<br>
<dt>Powers of units:</dt>
    <dd>"1 m^2"</dd>
    <dd>"1 m²" <i>(superscript integer)</i></dd>
<br>
<dt>Multiplication of to units:</dt>
    <dd>"1 N m" <i>(whitespace)</i></dd>
    <dd>"1 N . m"</dd>
    <dd>"1 N ⋅ m" <i>(centered dot)</i></dd>
    <dd>"1 N * m"</dd>
    <dd>"1 N × m" <i>(times sign)</i></dd>
<br>
<dt>Division of to units:</dt>
    <dd>"1 mol / s"</dd>
    <dd>"1 mol ÷ s"</dd>
<br>
<dt>Grouping of units with parentheses:</dt>
    <dd>"1 kg/(m.s^2)" = 1 kg m⁻¹ s⁻²</dd>
</dl>
<br><br>
<b>Grammar:</b><br>
(whitespace not significant)
<dl><dt>Quantity:</dt>
    <dd>Units</dd>
    <dd>Number Units</dd>
<br>
<dt>Number:</dt>
    <dd><i>Numeric value parsed by std.conv.parse!real</i></dd>
<br>
<dt>Units:</dt>
    <dd>Unit</dd>
    <dd>Unit Units</dd>
    <dd>Unit Operator Units</dd>
<br>
<dt>Operator:</dt>
    <dd><b>*</b></dd>
    <dd><b>.</b></dd>
    <dd><b>⋅</b></dd>
    <dd><b>×</b></dd>
    <dd><b>/</b></dd>
    <dd><b>÷</b></dd>
<br>
<dt>Unit:</dt>
    <dd>Base</dd>
    <dd>Base <b>^</b> Integer</dd>
    <dd>Base SupInteger</dd>
<br>
<dt>Base:</dt>
    <dd>Symbol</dd>
    <dd>Prefix Symbol</dd>
    <dd><b>(</b> Units <b>)</b></dd>
<br>
<dt>Symbol:</dt>
    <dd><i>The symbol of a valid unit</i></dd>
<br>
<dt>Prefix:</dt>
    <dd><i>The symbol of a valid prefix</i></dd>
<br>
<dt>Integer:</dt>
    <dd><i>Integer value parsed by std.conv.parse!int</i></dd>
<br>
<dt>SupInteger:</dt>
    <dd><i>Superscript version of Integer</i></dd>
</dl>

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="ctQuantityParser"></a>template <u>ctQuantityParser</u>(Sym...)</big></dt>
<dd>Creates a compile-time parser capable of working on user-defined units
and prefixes.
<br><br>
By default, the parser knows about SI units and prefixes. The user can add
more units and prefix in the template parameters, using the global addUnit and addPrefix
functions templates.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> bit = unit!<font color=red>"bit"</font>;
<font color=blue>enum</font> byte_ = 8 * bit;

<font color=blue>alias</font> sz = <u>ctQuantityParser</u>!(
    addUnit(<font color=red>"bit"</font>, bit),
    addUnit(<font color=red>"B"</font>, byte_),
    addPrefix(<font color=red>"hob"</font>, 7)
);

<font color=blue>enum</font> size = sz!<font color=red>"1 MiB"</font>;
<font color=blue>assert</font>(size.toString!(<font color=red>"%.0f bit"</font>, sz) == <font color=red>"8388608 bit"</font>);

<font color=blue>enum</font> height = sz!<font color=red>"1 hobbit"</font>;
<font color=blue>assert</font>(height.value(sz!<font color=red>"bit"</font>) == 7);
</pre>
<br><br>
</dd>
<dt><big><a name="si"></a>alias <u>si</u> = ctQuantityParser!().ctQuantityParser(string str, N = real);
</big></dt>
<dd>Parses a string for a a SI-compatible quantity.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> min = <u>si</u>!<font color=red>"min"</font>;
<font color=blue>enum</font> inch = <u>si</u>!<font color=red>"2.54 cm"</font>;

<font color=blue>auto</font> conc = <u>si</u>!<font color=red>"1 µmol/L"</font>;
<font color=blue>auto</font> speed = <u>si</u>!<font color=red>"m s^-1"</font>;
<font color=blue>auto</font> value = <u>si</u>!<font color=red>"0.5"</font>;

<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(conc) == Concentration));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(speed) == Speed));
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(value) == Dimensionless));
</pre>
<br><br>
</dd>
<dt><big><a name="parseQuantity"></a>auto <u>parseQuantity</u>(Q, S)(S <i>text</i>, SymbolList <i>symbolList</i> = SymbolList.siList) if (isQuantity!Q);
</big></dt>
<dd>Parses text for a unit or a quantity at runtime.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>alias</font> Time = QuantityType!second;
<font color=blue>alias</font> Length = QuantityType!meter;
<font color=green>// Note: these are also predefined in quantities.si
</font>
<font color=green>// Parse times
</font><font color=blue>auto</font> t = <u>parseQuantity</u>!Time(<font color=red>"90 min"</font>);
<font color=blue>assert</font>(t == 90 * minute);
t = <u>parseQuantity</u>!Time(<font color=red>"h"</font>);
<font color=blue>assert</font>(t == 1 * hour);

<font color=green>// Add a user-defined symbol (here a unit) to the default list
</font><font color=blue>auto</font> symbols = SymbolList.siList;
symbols.addUnit(<font color=red>"in"</font>, si!<font color=red>"2.54 cm"</font>);
<font color=blue>auto</font> len = <u>parseQuantity</u>!Length(<font color=red>"17 in"</font>, symbols);
<font color=blue>assert</font>(len.value(centi(meter)).approxEqual(17 * 2.54));
</pre>
<br><br>
</dd>
<dt><big><a name="SymbolList"></a>struct <u>SymbolList</u>;
</big></dt>
<dd>This struct contains the symbols of the units and the prefixes that the
parser can handle.<br><br>

<dl><dt><big><a name="SymbolList.siList"></a>static SymbolList <u>siList</u>();
</big></dt>
<dd>Returns the default list, consisting of the main SI units and prefixes.<br><br>

</dd>
<dt><big><a name="SymbolList.addPrefix"></a>void <u>addPrefix</u>(string <i>symbol</i>, real <i>factor</i>);
</big></dt>
<dd>Adds a new prefix to the list<br><br>

</dd>
<dt><big><a name="SymbolList.addUnit"></a>void <u>addUnit</u>(Q)(string <i>symbol</i>, Q <i>unit</i>) if (isQuantity!Q);
</big></dt>
<dd>Adds a new unit to the list<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ParsingException"></a>class <u>ParsingException</u>: object.Exception;
</big></dt>
<dd>Exception thrown when parsing encounters an unexpected token.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013, Nicolas Sicard
</small>
        </body></html>
