<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.parsing</title>
        </head><body>
        <h1>quantities.parsing</h1>
        <!-- Generated by Ddoc from source/quantities/parsing.d -->
This module defines functions to parse units and quantities. The text
input is parsed according to the following grammar. For example:
<dl><dt>Prefixes and unit symbols must be joined:</dt>
    <dd>"1 mm" = 1 millimeter</dd>
    <dd>"1 m m" = 1 square meter</dd>
<br>
<dt>Standalone units are preferred over prefixed ones:</dt>
    <dd>"1 cd" = 1 candela, not 1 centiday</dd>
<br>
<dt>Powers of units:</dt>
    <dd>"1 m^2"</dd>
    <dd>"1 m²" <i>(superscript integer)</i></dd>
<br>
<dt>Multiplication of to units:</dt>
    <dd>"1 N m" <i>(whitespace)</i></dd>
    <dd>"1 N . m"</dd>
    <dd>"1 N ⋅ m" <i>(centered dot)</i></dd>
    <dd>"1 N * m"</dd>
    <dd>"1 N × m" <i>(times sign)</i></dd>
<br>
<dt>Division of to units:</dt>
    <dd>"1 mol / s"</dd>
    <dd>"1 mol ÷ s"</dd>
<br>
<dt>Grouping of units with parentheses:</dt>
    <dd>"1 kg/(m.s^2)" = 1 kg m⁻¹ s⁻²</dd>
</dl>
<br><br>
<b>Grammar:</b><br>
(whitespace not significant)
<dl><dt>Quantity:</dt>
    <dd>Units</dd>
    <dd>Number Units</dd>
<br>
<dt>Number:</dt>
    <dd><i>Numeric value parsed by std.conv.parse!double</i></dd>
<br>
<dt>Units:</dt>
    <dd>Unit</dd>
    <dd>Unit Units</dd>
    <dd>Unit Operator Units</dd>
<br>
<dt>Operator:</dt>
    <dd><b>*</b></dd>
    <dd><b>.</b></dd>
    <dd><b>⋅</b></dd>
    <dd><b>×</b></dd>
    <dd><b>/</b></dd>
    <dd><b>÷</b></dd>
<br>
<dt>Unit:</dt>
    <dd>Base</dd>
    <dd>Base <b>^</b> Integer</dd>
    <dd>Base SupInteger</dd>
<br>
<dt>Base:</dt>
    <dd>Symbol</dd>
    <dd>Prefix Symbol</dd>
    <dd><b>(</b> Units <b>)</b></dd>
<br>
<dt>Symbol:</dt>
    <dd><i>The symbol of a valid unit</i></dd>
<br>
<dt>Prefix:</dt>
    <dd><i>The symbol of a valid prefix</i></dd>
<br>
<dt>Integer:</dt>
    <dd><i>Integer value parsed by std.conv.parse!int</i></dd>
<br>
<dt>SupInteger:</dt>
    <dd><i>Superscript version of Integer</i></dd>
</dl>

<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="DimensionException"></a>class <u>DimensionException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when operating on two units that are not interconvertible.<br><br>

</dd>
<dt><big><a name="SymbolList"></a>struct <u>SymbolList</u>(N);
</big></dt>
<dd>Contains the symbols of the units and the prefixes that a parser can handle.<br><br>

<dl><dt><big><a name="SymbolList.addUnit"></a>auto <u>addUnit</u>(Q)(string <i>symbol</i>, Q <i>unit</i>) if (isQuantity!Q);
</big></dt>
<dd>Adds (or replaces) a unit in the list<br><br>

</dd>
<dt><big><a name="SymbolList.addPrefix"></a>auto <u>addPrefix</u>(N)(string <i>symbol</i>, N <i>factor</i>) if (isNumberLike!N);
</big></dt>
<dd>Adds (or replaces) a prefix in the list<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="NumberParser"></a>template <u>NumberParser</u>(N)</big></dt>
<dd>Type of a function that can parse a string for a numeric value of type N.<br><br>

</dd>
<dt><big><a name="QuantityParams"></a>struct <u>QuantityParams</u>(N);
</big></dt>
<dd>Holds a value and dimensions<br><br>

<dl><dt><big><a name="QuantityParams.value"></a>N <u>value</u>;
</big></dt>
<dd>The parsed <u>value</u><br><br>

</dd>
<dt><big><a name="QuantityParams.dimensions"></a>int[string] <u>dimensions</u>;
</big></dt>
<dd>The parsed <u>dimensions</u><br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Parser"></a>struct <u>Parser</u>(N);
</big></dt>
<dd>A quantity parser<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=green>// From http://en.wikipedia.org/wiki/List_of_humorous_units_of_measurement
</font>
<font color=blue>enum</font> century = unit!(<font color=blue>real</font>, <font color=red>"century"</font>);
<font color=blue>alias</font> LectureLength = <font color=blue>typeof</font>(century);

<font color=blue>enum</font> symbolList = SymbolList!<font color=blue>real</font>()
    .addUnit(<font color=red>"Cy"</font>, century)
    .addPrefix(<font color=red>"µ"</font>, 1e-6L);

<font color=green>// At runtime
</font>{
    <font color=blue>import</font> std.conv;
    <font color=blue>auto</font> parser = <u>Parser</u>!<font color=blue>real</font>(symbolList, &amp;std.conv.parse!(<font color=blue>real</font>, string));

    <font color=blue>auto</font> timing = 1e-6L * century;
    <font color=blue>assert</font>(timing == parser.parse!LectureLength(<font color=red>"1 µCy"</font>));
}

<font color=green>// At compile-time
</font>{
    <font color=blue>import</font> std.conv;
    <font color=blue>enum</font> parser = <u>Parser</u>!<font color=blue>real</font>(symbolList, &amp;std.conv.parse!(<font color=blue>real</font>, string));
    
    <font color=blue>enum</font> timing = 1e-6L * century;
    <font color=blue>static</font> <font color=blue>assert</font>(timing == parser.parse!LectureLength(<font color=red>"1 µCy"</font>));
}
</pre>
<br><br>
<dl><dt><big><a name="Parser.symbolList"></a>SymbolList!N <u>symbolList</u>;
</big></dt>
<dd>A list of registered symbols for units and prefixes.<br><br>

</dd>
<dt><big><a name="Parser.numberParser"></a>NumberParser!N <u>numberParser</u>;
</big></dt>
<dd>A function that can parse a string for a numeric value of type N.<br><br>

</dd>
<dt><big><a name="Parser.parse"></a>Q <u>parse</u>(Q)(string <i>str</i>);
</big></dt>
<dd>Parses a quantity of a known type Q from a string.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="compileTimeParser"></a>template <u>compileTimeParser</u>(N, alias symbolList, alias numberParser)</big></dt>
<dd>Creates a compile-time parser that parses a string for a quantity and
<br><br>
automatically deduces the quantity type.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>enum</font> century = unit!(<font color=blue>real</font>, <font color=red>"century"</font>);
<font color=blue>alias</font> LectureLength = <font color=blue>typeof</font>(century);

<font color=blue>enum</font> symbolList = SymbolList!<font color=blue>real</font>()
    .addUnit(<font color=red>"Cy"</font>, century)
    .addPrefix(<font color=red>"µ"</font>, 1e-6L);

<font color=blue>alias</font> ctParser = <u>compileTimeParser</u>!(<font color=blue>real</font>, symbolList, std.conv.parse!(<font color=blue>real</font>, string));
<font color=blue>enum</font> timing = 1e-6L * century;
<font color=blue>static</font> <font color=blue>assert</font>(timing == ctParser!<font color=red>"1 µCy"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="ParsingException"></a>class <u>ParsingException</u>: <u>object.Exception</u>;
</big></dt>
<dd>Exception thrown when parsing encounters an unexpected token.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2015, Nicolas Sicard
</small>
        </body></html>
