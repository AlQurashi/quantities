<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>quantities.base</title>
        </head><body>
        <h1>quantities.base</h1>
        <!-- Generated by Ddoc from source/quantities/base.d -->
This module defines the <u>base</u> types for unit and quantity handling.
<br><br>
<b>Authors:</b><br>
Nicolas Sicard
<br><br>
<b>License:</b><br>
<a href="www.boost.org/LICENSE_1_0.txt, Boost License 1.0">www.boost.org/LICENSE_1_0.txt, Boost License 1.0</a>
<br><br>
<b>Source:</b><br>
<a href="https://github.com/biozic/quantities">https://github.com/biozic/quantities</a><br><br>

<dl><dt><big><a name="Quantity"></a>struct <u>Quantity</u>(N, Dimensions dims);
</big></dt>
<dd>A quantity  that can  be represented as  the product  of a number  and a  set of
dimensions. The  number is  stored internally as  a member of  type N,  which is
enforced to be a built-in numeric  type (isNumeric!N is <b>true</b>). The dimensions
are  stored as  an  associative array  where  keys are  symbols  and values  are
integral powers.
For  instance  length and  speed quantities can be stored as:
<pre class="d_code"><font color=blue>alias</font> Length = <u>Quantity</u>!(<font color=blue>double</font>, [<font color=red>"L"</font>: 1]);
<font color=blue>alias</font> Speed  = <u>Quantity</u>!(<font color=blue>double</font>, [<font color=red>"L"</font>: 1, <font color=red>"T"</font>: -1]);
</pre>
where "L" is the symbol for the length  dimension, "T" is the symbol of the time
dimensions,  and  1   and  -1  are  the  powers  of   those  dimensions  in  the
representation of the quantity.
<br><br>
Units are  just instances  of a  <u>Quantity</u> struct where  the value  is 1  and the
dimensions only  contain one symbol, with  the power 1. For  instance, the meter
unit can be defined using the template <pre style="display:inline;" class="d_inline_code">unit</pre> as:
<pre class="d_code"><font color=blue>enum</font> meter = unit!(<font color=blue>double</font>, <font color=red>"L"</font>);
<font color=blue>static</font> <font color=blue>assert</font>(<font color=blue>is</font>(<font color=blue>typeof</font>(meter) == <u>Quantity</u>!(<font color=blue>double</font>, [<font color=red>"L"</font>: 1])));
</pre>
The main  quantities compliant with the  international system of units  (SI) are
actually predefined  in  the module  quantities.si.
<br><br>

Any quantity can be expressed as the product  of a number (<i>n</i>) and a unit of
the right dimensions (<i>U</i>). For instance:
<pre class="d_code"><font color=blue>auto</font> size = 9.5 * meter;
<font color=blue>auto</font> time = 120 * milli(second);
</pre>
The unit  <i>U</i>  is not  actually stored along  with the  number in  a <u>Quantity</u>
struct,  only the  dimensions are.  This  is because  the same  quantity can  be
expressed in an  infinity of different units.  The value of <i>n</i>  is stored as
if the quantity was  expressed in the base units of the  same dimemsions. In the
example above,  <i>n</i> = 9.5  for the variable size  and <i>n</i> =  0.120 for the
variable time.
<br><br>

The method <pre style="display:inline;" class="d_inline_code">value</pre> can  be used  to  extract the  number  <i>n</i>  as  if it  was
expressed in  any possible  unit. The user  must pass this  unit to  the method.
This way, the user makes it clear in which unit the value was expressed.
<pre class="d_code"><font color=blue>auto</font> size = 9.5 * meter;
<font color=blue>auto</font> valueMeter      = size.value(meter);        <font color=green>// valueMeter == 9.5
</font><font color=blue>auto</font> valueCentimeter = size.value(centi(meter)); <font color=green>// valueCentimeter == 950
</font></pre>
Arithmetic operators (+ - * /),  as well as assignment and comparison operators,
are  defined when  the  operations are  dimensionally  consistent, otherwise  an
error occurs at compile-time:
<pre class="d_code"><font color=blue>auto</font> time = 2 * hour + 17 * minute;
<font color=blue>auto</font> frequency = time / second;
time = time + 2 * meter; <font color=green>// Compilation error
</font></pre>
Any kind  of quantities  and units  can be  defined with  this module,  not just
those  from the  SI. When  a quantity  that is  not predefined  has to  be used,
instead of instantiating the <u>Quantity</u> template  first, it is preferable to start
defining a new base unit (with only  one dimension) using the unit template, and
then the quantity type with the typeof operator:
<pre class="d_code"><font color=blue>enum</font> euro = unit!<font color=red>"C"</font>; <font color=green>// C for currency
</font><font color=blue>alias</font> Currency = <font color=blue>typeof</font>(euro);
<font color=blue>assert</font>(<font color=blue>is</font>(Currency == <u>Quantity</u>!(<font color=blue>double</font>, [<font color=red>"C"</font>: 1])));
</pre>
This means that all currencies will be defined with respect to euro.

<br><br>
<b>Params:</b><br>
<table><tr><td>N</td>
<td>The numeric type of the quantity used to store the value internally (e.g. <pre style="display:inline;" class="d_inline_code">double</pre>).</td></tr>
<tr><td>dims</td>
<td>The dimensions of the quantity.</td></tr>
</table><br>

<dl><dt><big><a name="Quantity.valueType"></a>alias <u>valueType</u> = N;
</big></dt>
<dd>The type of the underlying numeric value.<br><br>

</dd>
<dt><big><a name="Quantity.baseUnit"></a>static Quantity <u>baseUnit</u>();
</big></dt>
<dd>Gets the base unit of this quantity.<br><br>

</dd>
<dt><big><a name="Quantity.value"></a>const N <u>value</u>(Q)(Q <i>target</i>) if (isQuantity!Q);
</big></dt>
<dd>Gets the value of this quantity expressed in the given target unit.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> quantities.si : minute, hour;

<font color=blue>auto</font> time = 120 * minute;
<font color=blue>assert</font>(time.<u>value</u>(hour) == 2);
<font color=blue>assert</font>(time.<u>value</u>(minute) == 120);
</pre>
<br><br>
</dd>
<dt><big><a name="Quantity.isConsistentWith"></a>const bool <u>isConsistentWith</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
</big></dt>
<dd>Tests wheter this quantity has the same dimensions as another one.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> quantities.si : minute, second, meter;

<font color=blue>assert</font>(minute.<u>isConsistentWith</u>(second));
<font color=blue>assert</font>(!meter.<u>isConsistentWith</u>(second));
</pre>
<br><br>
</dd>
<dt><big><a name="Quantity.opCast"></a>const Q <u>opCast</u>(Q)() if (isQuantity!Q);
<br><a name="Quantity.opAssign"></a>void <u>opAssign</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="Quantity.opUnary"></a>const auto <u>opUnary</u>(string op)() if (op == "+" || op == "-");
<br>auto <u>opUnary</u>(string op)() if (op == "++" || op == "--");
<br><a name="Quantity.opBinary"></a>const auto <u>opBinary</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "+" || op == "-"));
<br>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="Quantity.opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br><a name="Quantity.opBinary.2"></a>const auto <u>opBinary</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br>const auto <u>opBinary</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="Quantity.opBinaryRight.2"></a>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; op == "*");
<br>const auto <u>opBinaryRight</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "/" || op == "%"));
<br><a name="Quantity.opOpAssign"></a>void <u>opOpAssign</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "+" || op == "-"));
<br>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "+" || op == "-"));
<br>void <u>opOpAssign</u>(string op, Q)(Q <i>other</i>) if (isQuantity!Q &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br>void <u>opOpAssign</u>(string op, T)(T <i>other</i>) if (isNumeric!T &amp;&amp; (op == "*" || op == "/" || op == "%"));
<br><a name="Quantity.opEquals"></a>const bool <u>opEquals</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br>const bool <u>opEquals</u>(T)(T <i>other</i>) if (isNumeric!T);
<br><a name="Quantity.opCmp"></a>const int <u>opCmp</u>(Q)(Q <i>other</i>) if (isQuantity!Q);
<br>const int <u>opCmp</u>(T)(T <i>other</i>) if (isNumeric!T);
</big></dt>
<dd>Overloaded operators.
<br><br>
Only dimensionally correct operations will compile.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="isQuantity"></a>template <u>isQuantity</u>(T)</big></dt>
<dd>Tests whether T is a quantity type<br><br>

</dd>
<dt><big><a name="unit"></a>template <u>unit</u>(N, string symbol)</big></dt>
<dd>Creates a new monodimensional <u>unit</u>.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> euro = <u>unit</u>!(<font color=blue>double</font>, <font color=red>"C"</font>); <font color=green>// C for Currency
</font><font color=blue>assert</font>(isQuantity!(<font color=blue>typeof</font>(euro)));
<font color=blue>auto</font> dollar = euro / 1.35;
<font color=blue>assert</font>((1.35 * dollar).value(euro).approxEqual(1));
</pre>
<br><br>
</dd>
<dt><big><a name="AreConsistent"></a>template <u>AreConsistent</u>(Q1, Q2) if (isQuantity!Q1 &amp;&amp; isQuantity!Q2)</big></dt>
<dd>Check that two quantity types are dimensionally consistent.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> quantities.si : meter, second;

<font color=blue>alias</font> Speed = <font color=blue>typeof</font>(meter/second);
<font color=blue>alias</font> Velocity = <font color=blue>typeof</font>((1/second * meter));
<font color=blue>static</font> <font color=blue>assert</font>(<u>AreConsistent</u>!(Speed, Velocity));
</pre>
<br><br>
</dd>
<dt><big><a name="prefix"></a>template <u>prefix</u>(alias factor)</big></dt>
<dd>Creates a new <u>prefix</u> function that mutlpy a Quantity by factor factor.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>import</font> quantities.si : meter;

<font color=blue>alias</font> milli = <u>prefix</u>!1e-3;
<font color=blue>assert</font>(milli(meter).value(meter).approxEqual(1e-3));
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2013-2015, Nicolas Sicard
</small>
        </body></html>
